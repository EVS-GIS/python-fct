{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Fluvial Corridor Toolbox Overview The scope of the Fluvial Corridor Toolbox (FCT) is fluvial geomorphology at the network scale, sometimes called upscaled hydromorphology. The toolbox enables mapping fluvial corridors and measuring river features from very large datasets. We first developed the toolbox for the case of the French Rhone basin, which is 90 000 km^2 wide. The overall goal of the toolbox is to propose a quantitative application of the river style framework to support evidence based river management and river condition monitoring in the context of integrated river management. This new version of the Fluvial Corridor Toolbox (FCT) started as an effort to implement port the ArcGIS code (Roux et al., 2015) to the QGis platform for promoting open science and sharing our tools with river practitioners. The new version has been completely rewritten and incorporates ideas from Nardi et al. (2018) and Clubb et al. (2017) for improving the calculation of riverscape feature heights above the water level and delineate floodplain through the river network. We also borrowed the concept of swath profiles from Hergarten et al. (2014) as the basis of a new raster-based approach to characterize floodplain features on cross-sections. These new functionalities are based on high resolution DEM and landcover data to produce nested floodplain envelops. Finally, we implemented tiled processing of very large raster datasets after Barnes (2016, 2017). This new version of the FCT also provides a lightweight framework for developing new processing toolchains/workflows. Basin-wide cartography The cartography of the French Rhone Basin is visible online as an example of the output of the FCT. Principles The FCT provides a framework to characterize river corridors at the network scale Enables the processing of high resolution datasets and/or wide watersheds Robust, reproducible and automated raster-based metrology FAIR and open source platform River Styles Based on the FCT extracted metrics, the river network can be segmented into functional units and classified into river styles. A river style represents a type of river behavior. River styles support better comparison between river reaches and are a useful tool to assess river condition. Workflows The FCT implements a number of complex workflows : Drainage network derived from DEM's topography Height maps relative to the river or drainage network Valley bottom delineation from height and slope Longitudinal reference system for river characterization and monitoring Lateral continuity Planform metrics Corridor metrics Heights A. flow height (Nardi et al., 2018) B. shortest height C. height above nearest drainage D. height above floodplain Example Metrics In order to measure and calculate metrics, the valley bottom is divided into longitudinal units of constant length. A number of metrics can be calculated by the toolbox. See the full list of metrics . Documentation The project still lacks a thorough documentation, but we strive to provide a working documentation as soon as possible.","title":"Introduction"},{"location":"#fluvial-corridor-toolbox","text":"","title":"Fluvial Corridor Toolbox"},{"location":"#overview","text":"The scope of the Fluvial Corridor Toolbox (FCT) is fluvial geomorphology at the network scale, sometimes called upscaled hydromorphology. The toolbox enables mapping fluvial corridors and measuring river features from very large datasets. We first developed the toolbox for the case of the French Rhone basin, which is 90 000 km^2 wide. The overall goal of the toolbox is to propose a quantitative application of the river style framework to support evidence based river management and river condition monitoring in the context of integrated river management. This new version of the Fluvial Corridor Toolbox (FCT) started as an effort to implement port the ArcGIS code (Roux et al., 2015) to the QGis platform for promoting open science and sharing our tools with river practitioners. The new version has been completely rewritten and incorporates ideas from Nardi et al. (2018) and Clubb et al. (2017) for improving the calculation of riverscape feature heights above the water level and delineate floodplain through the river network. We also borrowed the concept of swath profiles from Hergarten et al. (2014) as the basis of a new raster-based approach to characterize floodplain features on cross-sections. These new functionalities are based on high resolution DEM and landcover data to produce nested floodplain envelops. Finally, we implemented tiled processing of very large raster datasets after Barnes (2016, 2017). This new version of the FCT also provides a lightweight framework for developing new processing toolchains/workflows.","title":"Overview"},{"location":"#basin-wide-cartography","text":"The cartography of the French Rhone Basin is visible online as an example of the output of the FCT.","title":"Basin-wide cartography"},{"location":"#principles","text":"The FCT provides a framework to characterize river corridors at the network scale Enables the processing of high resolution datasets and/or wide watersheds Robust, reproducible and automated raster-based metrology FAIR and open source platform","title":"Principles"},{"location":"#river-styles","text":"Based on the FCT extracted metrics, the river network can be segmented into functional units and classified into river styles. A river style represents a type of river behavior. River styles support better comparison between river reaches and are a useful tool to assess river condition.","title":"River Styles"},{"location":"#workflows","text":"The FCT implements a number of complex workflows : Drainage network derived from DEM's topography Height maps relative to the river or drainage network Valley bottom delineation from height and slope Longitudinal reference system for river characterization and monitoring Lateral continuity Planform metrics Corridor metrics","title":"Workflows"},{"location":"#heights","text":"A. flow height (Nardi et al., 2018) B. shortest height C. height above nearest drainage D. height above floodplain","title":"Heights"},{"location":"#example-metrics","text":"In order to measure and calculate metrics, the valley bottom is divided into longitudinal units of constant length. A number of metrics can be calculated by the toolbox. See the full list of metrics .","title":"Example Metrics"},{"location":"#documentation","text":"The project still lacks a thorough documentation, but we strive to provide a working documentation as soon as possible.","title":"Documentation"},{"location":"acknowledgements/","text":"The toolbox is developed within the programme Trame bleue, espaces et continuit\u00e9s in collaboration with : GeoPeka UMR 5600 Environnement, ville et soci\u00e9t\u00e9 . Funding and support have been kindly provided by : European Union and R\u00e9gion Auvergne-Rh\u00f4ne-Alpes Association nationale pour la recherche technologique Agence de l'eau Rh\u00f4ne-M\u00e9diterran\u00e9e-Corse","title":"Acknowledgements"},{"location":"concepts/","text":"Concepts data model stream network (graph representation), axis spatial reference, coordinates, DGO? longitudinal profile, cross profile, swath profile tiled processing thematic topics : (-) elevation, height, valley bottom (-) land cover continuity analysis","title":"Concepts"},{"location":"concepts/#concepts","text":"data model stream network (graph representation), axis spatial reference, coordinates, DGO? longitudinal profile, cross profile, swath profile tiled processing thematic topics : (-) elevation, height, valley bottom (-) land cover continuity analysis","title":"Concepts"},{"location":"configuration/","text":"Configuration Workspace Datasource Dataset Tileset","title":"Configuration"},{"location":"credits/","text":"Credits","title":"Credits"},{"location":"credits/#credits","text":"","title":"Credits"},{"location":"framework/","text":"Framework The FCT provides a lightweight framework to execute chains of algorithms, which we will refer to as workflows . graph LR i1(datasource1) --> o1 i2(datasource2) --> o3 o1[operation 1] --> o2 o2[operation 2] --> o3 o1 --> o3 o3[operation 3] --> o4 o2 --> o4 o4[operation 4] --> f(output) Algorithm, Parameters and Operation An algorithm is a simple function that processes a set of input and produces a set of output. graph TB A1(datasources) --> B[Algorithm] A2(input datasets) --> B A3(parameters) --> B B --> C(output datasets) If an algorithm could be any python function, the FCT framework provides a simple mechanism to define input and output by parameters that can be resolved at execution time using configuration. We distinguish between 3 types of parameters : Datasource parameters which resolve to Datasources Input/Output dataset parameters which resolve to Datasets Literal parameters which represent simple (string or numeric) values Input and output datasets are basically the same thing : some output become the input to another step in the workflow. Datasources are input datasets that may reside anywhere outside the execution workspace, whereas datasets are resolved relatively to the current workspace location. One can think of datasources as primary data that need to be imported into the workspace, while datasets are first produced at some step before they are consumed by another one. Datasources and datasets ultimately resolve to file names, and as such, they can represent anything that can be stored in a file. Algorithms are responsible for managing access to specific file formats. In order to encourage consistent implementation of algorithms, we define Parameters and operations : Parameters represent a set of named parameters specific to some algorithm an operation is the realization of an algorithm, it is a function that instances a Parameters object, possibily binding concrete datasets to dataset parameters, and executes the algorithm with theses parameters. erDiagram Operation ||--|| Parameters: instances Operation }|--|| Algorithm : executes Parameters ||--o{ DatasourceParameter: defines Parameters ||--o{ DatasetParameter: defines Parameters ||--o{ LiteralParameter: defines DatasourceParameter ||..|| Datasource: resolves_to DatasetParameter ||..|| InputOutputDataset: resolves_to LiteralParameter ||..|| Value: resolves_to Example As an example, we could define a new FlowDirectionAlgorithm along with its Parameters class as : from fct.config import DatasetParameter class Parameters (): \"\"\" Flow direction parameters \"\"\" elevations = DatasetParameter ( 'elevation raster (DEM)' , type = 'input' ) flow = DatasetParameter ( 'flow direction raster' , type = 'output' ) def __init__ ( self ): \"\"\" Default parameter values \"\"\" self . elevations = 'dem' self . flow = 'flow' def FlowDirectionAlgorithm ( params : Parameters ): \"\"\" Algorithm stub \"\"\" print ( params . elevations . filename ()) print ( params . flow . filename ()) Finally, we could define a new operation that uses FlowDirectionAlgorithm to process specific input and output : @operation def flow_direction (): \"\"\" FlowDirectionAlgorithm realization \"\"\" # instances Parameters params = Parameters () params . elevations = 'other-dem' params . flow = 'other-flow' # executes algorithm FlowDirectionAlgorithm ( params )","title":"Framework"},{"location":"framework/#framework","text":"The FCT provides a lightweight framework to execute chains of algorithms, which we will refer to as workflows . graph LR i1(datasource1) --> o1 i2(datasource2) --> o3 o1[operation 1] --> o2 o2[operation 2] --> o3 o1 --> o3 o3[operation 3] --> o4 o2 --> o4 o4[operation 4] --> f(output)","title":"Framework"},{"location":"framework/#algorithm-parameters-and-operation","text":"An algorithm is a simple function that processes a set of input and produces a set of output. graph TB A1(datasources) --> B[Algorithm] A2(input datasets) --> B A3(parameters) --> B B --> C(output datasets) If an algorithm could be any python function, the FCT framework provides a simple mechanism to define input and output by parameters that can be resolved at execution time using configuration. We distinguish between 3 types of parameters : Datasource parameters which resolve to Datasources Input/Output dataset parameters which resolve to Datasets Literal parameters which represent simple (string or numeric) values Input and output datasets are basically the same thing : some output become the input to another step in the workflow. Datasources are input datasets that may reside anywhere outside the execution workspace, whereas datasets are resolved relatively to the current workspace location. One can think of datasources as primary data that need to be imported into the workspace, while datasets are first produced at some step before they are consumed by another one. Datasources and datasets ultimately resolve to file names, and as such, they can represent anything that can be stored in a file. Algorithms are responsible for managing access to specific file formats. In order to encourage consistent implementation of algorithms, we define Parameters and operations : Parameters represent a set of named parameters specific to some algorithm an operation is the realization of an algorithm, it is a function that instances a Parameters object, possibily binding concrete datasets to dataset parameters, and executes the algorithm with theses parameters. erDiagram Operation ||--|| Parameters: instances Operation }|--|| Algorithm : executes Parameters ||--o{ DatasourceParameter: defines Parameters ||--o{ DatasetParameter: defines Parameters ||--o{ LiteralParameter: defines DatasourceParameter ||..|| Datasource: resolves_to DatasetParameter ||..|| InputOutputDataset: resolves_to LiteralParameter ||..|| Value: resolves_to","title":"Algorithm, Parameters and Operation"},{"location":"framework/#example","text":"As an example, we could define a new FlowDirectionAlgorithm along with its Parameters class as : from fct.config import DatasetParameter class Parameters (): \"\"\" Flow direction parameters \"\"\" elevations = DatasetParameter ( 'elevation raster (DEM)' , type = 'input' ) flow = DatasetParameter ( 'flow direction raster' , type = 'output' ) def __init__ ( self ): \"\"\" Default parameter values \"\"\" self . elevations = 'dem' self . flow = 'flow' def FlowDirectionAlgorithm ( params : Parameters ): \"\"\" Algorithm stub \"\"\" print ( params . elevations . filename ()) print ( params . flow . filename ()) Finally, we could define a new operation that uses FlowDirectionAlgorithm to process specific input and output : @operation def flow_direction (): \"\"\" FlowDirectionAlgorithm realization \"\"\" # instances Parameters params = Parameters () params . elevations = 'other-dem' params . flow = 'other-flow' # executes algorithm FlowDirectionAlgorithm ( params )","title":"Example"},{"location":"install/","text":"Getting started Platform requirements Python 3.x (currently tested with Python 3.8) a C/C++ compiler in order to compile Cython extensions Install from GitHub Clone source code from GitHub : git clone --recursive https://github.com/tramebleue/fct-cli Create and activate a python virtual environment. We recommend not to create the python virtual environment inside the fct-cli directory. For example, you can create a pyenv directory in your home directory to store all your python virtual environments. You can give your new virtual environment whatever name you want. For example, we use fct . It will create a new fct directory : mkdir pyenv cd pyenv python3 -m venv fct . fct/bin/activate From directory fct-cli , install required dependencis using pip : python -m pip install -r requirements/fct.txt Build extensions and install modules : python -m pip install . If you would like to install in developement mode (links to source code rather than copy python modules to your site-packages folder), you can use the -e flag : python -m pip install -e .","title":"Getting started"},{"location":"install/#getting-started","text":"","title":"Getting started"},{"location":"install/#platform-requirements","text":"Python 3.x (currently tested with Python 3.8) a C/C++ compiler in order to compile Cython extensions","title":"Platform requirements"},{"location":"install/#install-from-github","text":"Clone source code from GitHub : git clone --recursive https://github.com/tramebleue/fct-cli Create and activate a python virtual environment. We recommend not to create the python virtual environment inside the fct-cli directory. For example, you can create a pyenv directory in your home directory to store all your python virtual environments. You can give your new virtual environment whatever name you want. For example, we use fct . It will create a new fct directory : mkdir pyenv cd pyenv python3 -m venv fct . fct/bin/activate From directory fct-cli , install required dependencis using pip : python -m pip install -r requirements/fct.txt Build extensions and install modules : python -m pip install . If you would like to install in developement mode (links to source code rather than copy python modules to your site-packages folder), you can use the -e flag : python -m pip install -e .","title":"Install from GitHub"},{"location":"license/","text":"The Fluvial Corridor Toolbox is released under the GNU Public License v3 .","title":"License"},{"location":"metrics/","text":"Example river profile summary, as printed by xarray , showing the list of synthetic metrics calculated by the FCT : <xarray.Dataset> Dimensions: (side: 2, swath: 8070) Coordinates: * side (side) object 'left' 'right' * swath (swath) MultiIndex - axis (swath) int64 15 15 15 15 15 ... 977 977 977 977 - measure (swath) float64 100.0 300.0 ... 1.7e+03 1.9e+03 Data variables: drainage_area (swath) float32 6.663e+04 6.574e+04 ... 5.682 length_axis (swath) float32 200.0 200.0 200.0 ... 200.0 200.0 length_talweg (swath) float32 201.7 222.5 181.7 ... 202.4 131.3 distance_source_talweg (swath) float32 1.124e+05 1.122e+05 ... 131.3 distance_source_refaxis (swath) float32 1.028e+05 1.026e+05 ... 200.0 0.0 elevation_talweg (swath) float32 90.69 90.7 90.77 ... 180.5 182.9 elevation_talweg_med (swath) float32 90.69 90.69 90.77 ... 180.5 182.6 elevation_valley_bottom (swath) float32 89.84 89.91 89.36 ... 180.1 183.3 slope_talweg (swath) float32 5.557e-05 0.0002063 ... 0.009102 slope_valley_bottom (swath) float32 5.509e-05 0.000214 ... 0.009033 height_talweg (swath) float32 0.9209 0.7964 ... 0.09631 11.23 height_valley_bottom (swath) float32 -0.1442 -1.106 ... -0.3784 -0.059 gradient_height (swath) float32 0.003197 0.0744 ... 2.074 0.0 gradient_index (swath) float32 1.643 38.17 35.02 ... 2.074 0.0 area_valley_bottom (swath) float32 2.043e+06 7.07e+05 ... 4.255e+04 width_valley_bottom (swath, side) float32 8.593e+03 ... 125.7 width_valley_bottom_ma (swath) float32 2.78e+03 2.78e+03 ... 191.3 154.6 width_continuity (swath) float32 1.022e+04 3.535e+03 ... 212.8 width_water_channel (swath) float32 5.028e+03 1.037e+03 ... 0.0 6.855 width_active_channel (swath) float32 5.268e+03 1.051e+03 ... 0.0 6.855 width_natural_corridor (swath, side) float32 1.14e+03 79.6 ... 6.491 width_connected_corridor (swath, side) float32 1.505e+03 79.6 ... 117.7 amplitude (swath) float32 30.69 35.05 39.78 ... 13.89 11.68 omega (swath) float32 0.1366 0.1715 ... 0.1125 0.0844 wavelength (swath) float32 883.1 ... 1.257e+03 1.257e+03 sinuosity_length_ratio (swath) float32 1.01 1.002 ... 0.9153 0.8896 sinuosity_omega (swath) float32 1.017 1.027 1.042 ... 1.012 1.007 sinuosity_slope_ratio (swath) float32 1.0 1.038 1.024 ... 1.034 1.0 functional_unit (swath) uint32 1 1 1 1 1 1 ... 563 563 563 563 563 river_style (swath) object 'S4' 'S4' 'S4' ... 'S4' 'S4' 'S4'","title":"Metrics"},{"location":"references/","text":"Alber, A. and Pi\u00e9gay, H. (2011). Spatial disaggregation and aggregation procedures for characterizing fluvial features at the network-scale\u202f: Application to the Rh\u00f4ne basin (France) . Geomorphology, 125(3), 343 360. doi:10.1016/j.geomorph.2010.09.009 Barnes, R. (2016). Parallel Priority-Flood depression filling for trillion cell digital elevation models on desktops or clusters . Computers & Geosciences, 96, 56 68. doi:10.1016/j.cageo.2016.07.001 Barnes, R. (2017). Parallel non-divergent flow accumulation for trillion cell digital elevation models on desktops or clusters . Environmental Modelling & Software, 92, 202 212. doi:10.1016/j.envsoft.2017.02.022 Clubb, F. J., Mudd, S. M. & al. (2017). Geomorphometric delineation of floodplains and terraces from objectively defined topographic thresholds . Earth Surface Dynamics, 5(3), 369 385. doi:10.5194/esurf-5-369-2017 Fryirs, K. A., Wheaton, J. M. & al. (2019). To plug\u2010in or not to plug\u2010in? Geomorphic analysis of rivers using the River Styles Framework in an era of big data acquisition and automation . Wiley Interdisciplinary Reviews: Water, 6(5). doi:10.1002/wat2.1372 Gurnell, A. M., Rinaldi, M. & al. (2016). A multi-scale hierarchical framework for developing understanding of river behaviour to support river management . Aquatic Sciences, 78(1), 1 16. doi:10.1007/s00027-015-0424-5 Hergarten, S., Robl, J. & St\u00fcwe, K. (2014). Extracting topographic swath profiles across curved geomorphic features . Earth Surface Dynamics, 2(1), 97 104. doi:10.5194/esurf-2-97-2014 Nardi, F., Morrison, R. R. & al. (2018). Hydrologic scaling for hydrogeomorphic floodplain mapping\u202f: Insights into human\u2010induced floodplain disconnectivity . River Research and Applications, 34(7), 675 685. doi:10.1002/rra.3296 Pi\u00e9gay, H., Alber, A. & al. (2012). Biophysical Characterisation of Fluvial Corridors at Reach to Network Scales . In P. E. Carbonneau & H. Pi\u00e9gay (\u00c9ds.), Fluvial Remote Sensing for Science and Management (p. 241 269). John Wiley & Sons, Ltd. doi:10.1002/9781119940791.ch11 Roux, C., Alber, A. & al. (2015). \u201cFluvialCorridor\u201d\u202f: A new ArcGIS toolbox package for multiscale riverscape exploration . Geomorphology, 242, 29 37. doi:10.1016/j.geomorph.2014.04.018","title":"References"},{"location":"examples/math/","text":"Example math p(x|y) = \\frac{p(y|x)p(x)}{p(y)} p(x|y) = \\frac{p(y|x)p(x)}{p(y)} p(x|y) = \\frac{p(y|x)p(x)}{p(y)} p(x|y) = \\frac{p(y|x)p(x)}{p(y)} . p(x|y) = \\frac{p(y|x)p(x)}{p(y)}","title":"Example math"},{"location":"examples/math/#example-math","text":"p(x|y) = \\frac{p(y|x)p(x)}{p(y)} p(x|y) = \\frac{p(y|x)p(x)}{p(y)} p(x|y) = \\frac{p(y|x)p(x)}{p(y)} p(x|y) = \\frac{p(y|x)p(x)}{p(y)} . p(x|y) = \\frac{p(y|x)p(x)}{p(y)}","title":"Example math"},{"location":"examples/mermaid/","text":"Mermaid Diagram Example graph TD A --> C subgraph G1 A --> B end subgraph G2 D --> E end subgraph G3 F --> C end graph TD A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2]","title":"Mermaid Diagram Example"},{"location":"examples/mermaid/#mermaid-diagram-example","text":"graph TD A --> C subgraph G1 A --> B end subgraph G2 D --> E end subgraph G3 F --> C end graph TD A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2]","title":"Mermaid Diagram Example"},{"location":"ref/api/","text":"API Configuration Configuration Classes Classes fct.config.Configuration.Configuration Configuration singleton, which can be read from a .ini file. Configuration defines: datasources tilesets datasets shared parameters: workdir, srid Attributes srid property readonly Return SRID touched property readonly Return list of datasets which have been accessed or created during processing session vertical_ref property readonly Vertical reference system for elevations workdir property readonly Return working directory Methods auto ( self ) Populate configuration from config.ini defined in FCT_CONFIG environment variable. Use .env if exists. axes ( self , name ) Returns all axes defined in named dataset basename ( self , name , ** kwargs ) Return Dataset filename relative to workdir configure ( self , workspace , datasources , datasets , tilesets ) Populate configuration dataset ( self , name ) Return Dataset by name/key datasource ( self , name ) Return DataSource definition default ( self ) Populate configuration from default config.ini filename ( self , name , ** kwargs ) Return Dataset filename instance from_file ( self , filename ) Populate configuration from .ini file tileset ( self , name = 'default' ) Return Tileset definition fct.config.Configuration.Dataset Describes an output dataset Attributes ext property readonly Return file extension name property readonly Return dataset's name Methods filename ( self , ** kwargs ) Return filename instance subdir ( self , ** kwargs ) Return storage subdirectory tilename ( self , ** kwargs ) Return tilename instance fct.config.Configuration.DataSource DataSource(name, filename, resolution) Attributes filename : None property readonly itemgetter(item, ...) --> itemgetter object Return a callable object that fetches the given item(s) from its operand. After f = itemgetter(2), the call f(r) returns r[2]. After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3]) name : None property readonly itemgetter(item, ...) --> itemgetter object Return a callable object that fetches the given item(s) from its operand. After f = itemgetter(2), the call f(r) returns r[2]. After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3]) resolution : None property readonly itemgetter(item, ...) --> itemgetter object Return a callable object that fetches the given item(s) from its operand. After f = itemgetter(2), the call f(r) returns r[2]. After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3]) Methods __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. __new__ ( _cls , name , filename , resolution ) special staticmethod Create new instance of DataSource(name, filename, resolution) __repr__ ( self ) special Return a nicely formatted representation string fct.config.Configuration.FileParser Read configuration components form a .ini file Methods datasets ( data ) staticmethod Read YAML dataset definitions and return a dict of datasets datasource ( name , items ) staticmethod Populate a DataSource object load_dataset_yaml ( configfile ) staticmethod Read dataset definitions from datasets directory or from `datasets.yml parse ( configfile ) staticmethod Main parsing method tileset ( name , items ) staticmethod Populate a Tileset object fct.config.Configuration.Tileset Describes a tileset from a shapefile index Attributes bounds property readonly (minx, miny, maxx, maxy) bounds of this tileset height property readonly Height in pixels of one tile name property readonly Name of this tileset tiledir property readonly Tile storage relative to dataset path tileindex property readonly Index of tiles belonging to this tileset width property readonly Width in pixels of one tile Methods __len__ ( self ) special Return number of tiles in tileindex filename ( self , dataset , ** kwargs ) Return dataset main file with tileset qualifier index ( self , x , y ) Return tile coordinates of real world point (x, y) tilename ( self , dataset , row , col , ** kwargs ) Return full-path filename instance for specific tile tiles ( self ) Generator of tiles fct.config.Configuration.Workspace Shared parameters and output dataset definitions Attributes srid property readonly Return SRID srs property readonly Return SRS Identifier workdir property readonly Return working directory Methods copy ( self ) Returns a deep copy of this object set_srs ( self , srs ) Set SRS descriptors Classes fct.config.descriptors.DatasetParameter A file-based dataset declared in datasets.yml , either tiled or not fct.config.descriptors.DatasetResolver Resolves a DatasetParameter according to current configuration. Attributes name property readonly Return dataset's key none property readonly Return True if this parameter should resolve to None Methods filename ( self , mode = 'r' , tileset = 'default' , ** kwargs ) Resolves to this datasource filename. If tileset is None, returns a global dataset. Otherwise, returns the single-file dataset for the specified tileset, such as a VRT file for tiled datasets. tilename ( self , mode = 'r' , tileset = 'default' , ** kwargs ) Resolves to a specific tilename based on kwargs arguments fct.config.descriptors.DatasourceParameter A file-based datasource declared in config.ini fct.config.descriptors.DatasourceResolver Resolves a DatasourceParameter according to current configuration. Attributes name property readonly Return datasource's key none property readonly Return True if this parameter should resolve to None Methods filename ( self ) Resolves to this datasource filename fct.config.descriptors.LiteralParameter A simple valued (string or numeric) parameter fct.config.descriptors.WorkflowContext A context manager that manages workflow execution: - allows specific execution settings - records execution details. Methods after_operation ( self , operation , * args , ** kwargs ) After-execution hook before_operation ( self , operation , * args , ** kwargs ) Before-execution hook record_execution_time ( self , operation , elapsed ) Record execution time for operation name set_outputdir ( self , outputdir ) Set output directory within workspace's working directory set_tiledir ( self , tiledir ) Set default tileset's tile directory set_tileset ( self , tileset ) Set current default tileset set_workdir ( self , workdir ) Set current workspace's working directory Functions fct . config . descriptors . pretty_time_delta ( delta ) See https://gist.github.com/thatalextaylor/7408395 workflows.decorators Decorators for building workflows workflows . decorators . operation ( fun ) Decorates a workflow operation Source code in workflows/decorators.py def operation ( fun ): \"\"\" Decorates a workflow operation \"\"\" @wraps ( fun ) def decorated ( ctx , * args , ** kwargs ): ctx . before_operation ( fun , * args , ** kwargs ) fun ( * args , ** kwargs ) ctx . after_operation ( fun , * args , ** kwargs ) return decorated workflows . decorators . parallel ( tilefun ) Decorates tilefun to process tiles in parallel using a Multiprocessing wrapper. Source code in workflows/decorators.py def parallel ( tilefun ): \"\"\" Decorates `tilefun` to process tiles in parallel using a Multiprocessing wrapper. \"\"\" @wraps ( tilefun ) def decorated ( tileset , * args , processes = 1 , ** kwargs ): \"\"\" Multiprocessing wrapper See https://stackoverflow.com/questions/8804830/python-multiprocessing-picklingerror-cant-pickle-type-function \"\"\" def arguments (): for tile in tileset . tiles (): yield [ tilefun , tile . row , tile . col , * args , kwargs ] with Pool ( processes = processes ) as pool : pooled = pool . imap_unordered ( starcall , arguments ()) with click . progressbar ( pooled , length = len ( tileset )) as iterator : for _ in iterator : # click.echo('\\n\\r') pass return decorated","title":"API"},{"location":"ref/api/#api","text":"","title":"API"},{"location":"ref/api/#fct.config.Configuration","text":"Configuration Classes","title":"Configuration"},{"location":"ref/api/#classes","text":"","title":"Classes"},{"location":"ref/api/#fct.config.Configuration.Configuration","text":"Configuration singleton, which can be read from a .ini file. Configuration defines: datasources tilesets datasets shared parameters: workdir, srid","title":"Configuration"},{"location":"ref/api/#attributes","text":"","title":"Attributes"},{"location":"ref/api/#fct.config.Configuration.Configuration.srid","text":"Return SRID","title":"srid"},{"location":"ref/api/#fct.config.Configuration.Configuration.touched","text":"Return list of datasets which have been accessed or created during processing session","title":"touched"},{"location":"ref/api/#fct.config.Configuration.Configuration.vertical_ref","text":"Vertical reference system for elevations","title":"vertical_ref"},{"location":"ref/api/#fct.config.Configuration.Configuration.workdir","text":"Return working directory","title":"workdir"},{"location":"ref/api/#methods","text":"","title":"Methods"},{"location":"ref/api/#fct.config.Configuration.Configuration.auto","text":"Populate configuration from config.ini defined in FCT_CONFIG environment variable. Use .env if exists.","title":"auto()"},{"location":"ref/api/#fct.config.Configuration.Configuration.axes","text":"Returns all axes defined in named dataset","title":"axes()"},{"location":"ref/api/#fct.config.Configuration.Configuration.basename","text":"Return Dataset filename relative to workdir","title":"basename()"},{"location":"ref/api/#fct.config.Configuration.Configuration.configure","text":"Populate configuration","title":"configure()"},{"location":"ref/api/#fct.config.Configuration.Configuration.dataset","text":"Return Dataset by name/key","title":"dataset()"},{"location":"ref/api/#fct.config.Configuration.Configuration.datasource","text":"Return DataSource definition","title":"datasource()"},{"location":"ref/api/#fct.config.Configuration.Configuration.default","text":"Populate configuration from default config.ini","title":"default()"},{"location":"ref/api/#fct.config.Configuration.Configuration.filename","text":"Return Dataset filename instance","title":"filename()"},{"location":"ref/api/#fct.config.Configuration.Configuration.from_file","text":"Populate configuration from .ini file","title":"from_file()"},{"location":"ref/api/#fct.config.Configuration.Configuration.tileset","text":"Return Tileset definition","title":"tileset()"},{"location":"ref/api/#fct.config.Configuration.Dataset","text":"Describes an output dataset","title":"Dataset"},{"location":"ref/api/#attributes_1","text":"","title":"Attributes"},{"location":"ref/api/#fct.config.Configuration.Dataset.ext","text":"Return file extension","title":"ext"},{"location":"ref/api/#fct.config.Configuration.Dataset.name","text":"Return dataset's name","title":"name"},{"location":"ref/api/#methods_1","text":"","title":"Methods"},{"location":"ref/api/#fct.config.Configuration.Dataset.filename","text":"Return filename instance","title":"filename()"},{"location":"ref/api/#fct.config.Configuration.Dataset.subdir","text":"Return storage subdirectory","title":"subdir()"},{"location":"ref/api/#fct.config.Configuration.Dataset.tilename","text":"Return tilename instance","title":"tilename()"},{"location":"ref/api/#fct.config.Configuration.DataSource","text":"DataSource(name, filename, resolution)","title":"DataSource"},{"location":"ref/api/#attributes_2","text":"","title":"Attributes"},{"location":"ref/api/#fct.config.Configuration.DataSource.filename","text":"itemgetter(item, ...) --> itemgetter object Return a callable object that fetches the given item(s) from its operand. After f = itemgetter(2), the call f(r) returns r[2]. After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])","title":"filename"},{"location":"ref/api/#fct.config.Configuration.DataSource.name","text":"itemgetter(item, ...) --> itemgetter object Return a callable object that fetches the given item(s) from its operand. After f = itemgetter(2), the call f(r) returns r[2]. After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])","title":"name"},{"location":"ref/api/#fct.config.Configuration.DataSource.resolution","text":"itemgetter(item, ...) --> itemgetter object Return a callable object that fetches the given item(s) from its operand. After f = itemgetter(2), the call f(r) returns r[2]. After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])","title":"resolution"},{"location":"ref/api/#methods_2","text":"","title":"Methods"},{"location":"ref/api/#fct.config.Configuration.DataSource.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle.","title":"__getnewargs__()"},{"location":"ref/api/#fct.config.Configuration.DataSource.__new__","text":"Create new instance of DataSource(name, filename, resolution)","title":"__new__()"},{"location":"ref/api/#fct.config.Configuration.DataSource.__repr__","text":"Return a nicely formatted representation string","title":"__repr__()"},{"location":"ref/api/#fct.config.Configuration.FileParser","text":"Read configuration components form a .ini file","title":"FileParser"},{"location":"ref/api/#methods_3","text":"","title":"Methods"},{"location":"ref/api/#fct.config.Configuration.FileParser.datasets","text":"Read YAML dataset definitions and return a dict of datasets","title":"datasets()"},{"location":"ref/api/#fct.config.Configuration.FileParser.datasource","text":"Populate a DataSource object","title":"datasource()"},{"location":"ref/api/#fct.config.Configuration.FileParser.load_dataset_yaml","text":"Read dataset definitions from datasets directory or from `datasets.yml","title":"load_dataset_yaml()"},{"location":"ref/api/#fct.config.Configuration.FileParser.parse","text":"Main parsing method","title":"parse()"},{"location":"ref/api/#fct.config.Configuration.FileParser.tileset","text":"Populate a Tileset object","title":"tileset()"},{"location":"ref/api/#fct.config.Configuration.Tileset","text":"Describes a tileset from a shapefile index","title":"Tileset"},{"location":"ref/api/#attributes_3","text":"","title":"Attributes"},{"location":"ref/api/#fct.config.Configuration.Tileset.bounds","text":"(minx, miny, maxx, maxy) bounds of this tileset","title":"bounds"},{"location":"ref/api/#fct.config.Configuration.Tileset.height","text":"Height in pixels of one tile","title":"height"},{"location":"ref/api/#fct.config.Configuration.Tileset.name","text":"Name of this tileset","title":"name"},{"location":"ref/api/#fct.config.Configuration.Tileset.tiledir","text":"Tile storage relative to dataset path","title":"tiledir"},{"location":"ref/api/#fct.config.Configuration.Tileset.tileindex","text":"Index of tiles belonging to this tileset","title":"tileindex"},{"location":"ref/api/#fct.config.Configuration.Tileset.width","text":"Width in pixels of one tile","title":"width"},{"location":"ref/api/#methods_4","text":"","title":"Methods"},{"location":"ref/api/#fct.config.Configuration.Tileset.__len__","text":"Return number of tiles in tileindex","title":"__len__()"},{"location":"ref/api/#fct.config.Configuration.Tileset.filename","text":"Return dataset main file with tileset qualifier","title":"filename()"},{"location":"ref/api/#fct.config.Configuration.Tileset.index","text":"Return tile coordinates of real world point (x, y)","title":"index()"},{"location":"ref/api/#fct.config.Configuration.Tileset.tilename","text":"Return full-path filename instance for specific tile","title":"tilename()"},{"location":"ref/api/#fct.config.Configuration.Tileset.tiles","text":"Generator of tiles","title":"tiles()"},{"location":"ref/api/#fct.config.Configuration.Workspace","text":"Shared parameters and output dataset definitions","title":"Workspace"},{"location":"ref/api/#attributes_4","text":"","title":"Attributes"},{"location":"ref/api/#fct.config.Configuration.Workspace.srid","text":"Return SRID","title":"srid"},{"location":"ref/api/#fct.config.Configuration.Workspace.srs","text":"Return SRS Identifier","title":"srs"},{"location":"ref/api/#fct.config.Configuration.Workspace.workdir","text":"Return working directory","title":"workdir"},{"location":"ref/api/#methods_5","text":"","title":"Methods"},{"location":"ref/api/#fct.config.Configuration.Workspace.copy","text":"Returns a deep copy of this object","title":"copy()"},{"location":"ref/api/#fct.config.Configuration.Workspace.set_srs","text":"Set SRS","title":"set_srs()"},{"location":"ref/api/#fct.config.descriptors","text":"","title":"descriptors"},{"location":"ref/api/#classes_1","text":"","title":"Classes"},{"location":"ref/api/#fct.config.descriptors.DatasetParameter","text":"A file-based dataset declared in datasets.yml , either tiled or not","title":"DatasetParameter"},{"location":"ref/api/#fct.config.descriptors.DatasetResolver","text":"Resolves a DatasetParameter according to current configuration.","title":"DatasetResolver"},{"location":"ref/api/#attributes_5","text":"","title":"Attributes"},{"location":"ref/api/#fct.config.descriptors.DatasetResolver.name","text":"Return dataset's key","title":"name"},{"location":"ref/api/#fct.config.descriptors.DatasetResolver.none","text":"Return True if this parameter should resolve to None","title":"none"},{"location":"ref/api/#methods_6","text":"","title":"Methods"},{"location":"ref/api/#fct.config.descriptors.DatasetResolver.filename","text":"Resolves to this datasource filename. If tileset is None, returns a global dataset. Otherwise, returns the single-file dataset for the specified tileset, such as a VRT file for tiled datasets.","title":"filename()"},{"location":"ref/api/#fct.config.descriptors.DatasetResolver.tilename","text":"Resolves to a specific tilename based on kwargs arguments","title":"tilename()"},{"location":"ref/api/#fct.config.descriptors.DatasourceParameter","text":"A file-based datasource declared in config.ini","title":"DatasourceParameter"},{"location":"ref/api/#fct.config.descriptors.DatasourceResolver","text":"Resolves a DatasourceParameter according to current configuration.","title":"DatasourceResolver"},{"location":"ref/api/#attributes_6","text":"","title":"Attributes"},{"location":"ref/api/#fct.config.descriptors.DatasourceResolver.name","text":"Return datasource's key","title":"name"},{"location":"ref/api/#fct.config.descriptors.DatasourceResolver.none","text":"Return True if this parameter should resolve to None","title":"none"},{"location":"ref/api/#methods_7","text":"","title":"Methods"},{"location":"ref/api/#fct.config.descriptors.DatasourceResolver.filename","text":"Resolves to this datasource filename","title":"filename()"},{"location":"ref/api/#fct.config.descriptors.LiteralParameter","text":"A simple valued (string or numeric) parameter","title":"LiteralParameter"},{"location":"ref/api/#fct.config.descriptors.WorkflowContext","text":"A context manager that manages workflow execution: - allows specific execution settings - records execution details.","title":"WorkflowContext"},{"location":"ref/api/#methods_8","text":"","title":"Methods"},{"location":"ref/api/#fct.config.descriptors.WorkflowContext.after_operation","text":"After-execution hook","title":"after_operation()"},{"location":"ref/api/#fct.config.descriptors.WorkflowContext.before_operation","text":"Before-execution hook","title":"before_operation()"},{"location":"ref/api/#fct.config.descriptors.WorkflowContext.record_execution_time","text":"Record execution time for operation name","title":"record_execution_time()"},{"location":"ref/api/#fct.config.descriptors.WorkflowContext.set_outputdir","text":"Set output directory within workspace's working directory","title":"set_outputdir()"},{"location":"ref/api/#fct.config.descriptors.WorkflowContext.set_tiledir","text":"Set default tileset's tile directory","title":"set_tiledir()"},{"location":"ref/api/#fct.config.descriptors.WorkflowContext.set_tileset","text":"Set current default tileset","title":"set_tileset()"},{"location":"ref/api/#fct.config.descriptors.WorkflowContext.set_workdir","text":"Set current workspace's working directory","title":"set_workdir()"},{"location":"ref/api/#functions","text":"","title":"Functions"},{"location":"ref/api/#fct.config.descriptors.pretty_time_delta","text":"See https://gist.github.com/thatalextaylor/7408395","title":"pretty_time_delta()"},{"location":"ref/api/#workflows.decorators","text":"Decorators for building workflows","title":"decorators"},{"location":"ref/api/#workflows.decorators.operation","text":"Decorates a workflow operation Source code in workflows/decorators.py def operation ( fun ): \"\"\" Decorates a workflow operation \"\"\" @wraps ( fun ) def decorated ( ctx , * args , ** kwargs ): ctx . before_operation ( fun , * args , ** kwargs ) fun ( * args , ** kwargs ) ctx . after_operation ( fun , * args , ** kwargs ) return decorated","title":"operation()"},{"location":"ref/api/#workflows.decorators.parallel","text":"Decorates tilefun to process tiles in parallel using a Multiprocessing wrapper. Source code in workflows/decorators.py def parallel ( tilefun ): \"\"\" Decorates `tilefun` to process tiles in parallel using a Multiprocessing wrapper. \"\"\" @wraps ( tilefun ) def decorated ( tileset , * args , processes = 1 , ** kwargs ): \"\"\" Multiprocessing wrapper See https://stackoverflow.com/questions/8804830/python-multiprocessing-picklingerror-cant-pickle-type-function \"\"\" def arguments (): for tile in tileset . tiles (): yield [ tilefun , tile . row , tile . col , * args , kwargs ] with Pool ( processes = processes ) as pool : pooled = pool . imap_unordered ( starcall , arguments ()) with click . progressbar ( pooled , length = len ( tileset )) as iterator : for _ in iterator : # click.echo('\\n\\r') pass return decorated","title":"parallel()"},{"location":"ref/drainage/","text":"Drainage fct.drainage.FlowDirection Flow Direction Module Parameters Flow direction parameters Attributes: Name Type Description exterior DatasourceParameter exterior domain default = 0.0 elevations filled-resolved elevation raster (DEM) flow flow direction raster __init__ ( self ) special Default parameter values FlowDirectionTile ( row , col , params , overwrite = True , ** kwargs ) Resolve flats drainage direction and calculate D8 flow direction from adjusted elevations. Parameters: Name Type Description Default row int tile row index required col int tile column index required params Parameters flow direction input/output parameters required overwrite bool if true, overwrite existing output, otherwise skip processing True kwargs Any extra parameters to be passed to dataset parameters defined in params {} WallFlats ( padded , nodata ) Raise elevation of noflow pixels on tile borders receiving flow from outside. Parameters: Name Type Description Default padded ndarray one-pixel padded tile data required nodata Any no-data value in padded required Returns: Type Description int number of raised pixels","title":"Drainage"},{"location":"ref/drainage/#drainage","text":"","title":"Drainage"},{"location":"ref/drainage/#fct.drainage.FlowDirection","text":"Flow Direction Module","title":"FlowDirection"},{"location":"ref/drainage/#fct.drainage.FlowDirection.Parameters","text":"Flow direction parameters Attributes: Name Type Description exterior DatasourceParameter exterior domain default = 0.0 elevations filled-resolved elevation raster (DEM) flow flow direction raster","title":"Parameters"},{"location":"ref/drainage/#fct.drainage.FlowDirection.Parameters.__init__","text":"Default parameter values","title":"__init__()"},{"location":"ref/drainage/#fct.drainage.FlowDirection.FlowDirectionTile","text":"Resolve flats drainage direction and calculate D8 flow direction from adjusted elevations. Parameters: Name Type Description Default row int tile row index required col int tile column index required params Parameters flow direction input/output parameters required overwrite bool if true, overwrite existing output, otherwise skip processing True kwargs Any extra parameters to be passed to dataset parameters defined in params {}","title":"FlowDirectionTile()"},{"location":"ref/drainage/#fct.drainage.FlowDirection.WallFlats","text":"Raise elevation of noflow pixels on tile borders receiving flow from outside. Parameters: Name Type Description Default padded ndarray one-pixel padded tile data required nodata Any no-data value in padded required Returns: Type Description int number of raised pixels","title":"WallFlats()"},{"location":"ref/metrics/","text":"","title":"Metrics"},{"location":"ref/network/","text":"","title":"Network"},{"location":"ref/speedup/","text":"FCT Algorithms Flow and drainage calculation D8 drainage algorithms fct . algorithms . drainage . flow_accumulation ( flow , out = None ) Flow accumulation from D8 flow direction. Parameters: Name Type Description Default flow ndarray D8 flow direction raster, ndim=2, dtype='int8', nodata=-1 required out Optional[numpy.ndarray] output float32 array initialized to 0 None Returns: Type Description ndarray float32 accumulation raster fct . algorithms . drainage . outlets ( flow ) Find all cells flowing outside of raster Parameters: Name Type Description Default flow ndarray D8 flow direction raster, ndim=2, dtype='int8', nodata=-1 required Returns: Type Description Tuple[List, List] list of outlet pixel coordinates (row, col) list of corresponding target pixel coordinates (row, col) outside of raster range Continuity analysis General raster processing","title":"FCT Algorithms"},{"location":"ref/speedup/#fct-algorithms","text":"","title":"FCT Algorithms"},{"location":"ref/speedup/#flow-and-drainage-calculation","text":"D8 drainage algorithms","title":"Flow and drainage calculation"},{"location":"ref/speedup/#fct.algorithms.drainage.flow_accumulation","text":"Flow accumulation from D8 flow direction. Parameters: Name Type Description Default flow ndarray D8 flow direction raster, ndim=2, dtype='int8', nodata=-1 required out Optional[numpy.ndarray] output float32 array initialized to 0 None Returns: Type Description ndarray float32 accumulation raster","title":"flow_accumulation()"},{"location":"ref/speedup/#fct.algorithms.drainage.outlets","text":"Find all cells flowing outside of raster Parameters: Name Type Description Default flow ndarray D8 flow direction raster, ndim=2, dtype='int8', nodata=-1 required Returns: Type Description Tuple[List, List] list of outlet pixel coordinates (row, col) list of corresponding target pixel coordinates (row, col) outside of raster range","title":"outlets()"},{"location":"ref/speedup/#continuity-analysis","text":"","title":"Continuity analysis"},{"location":"ref/speedup/#general-raster-processing","text":"","title":"General raster processing"},{"location":"ref/terrain/","text":"Terrain Analysis Some older code from FCT Terrain Analysis fct . algorithms . terrain . disaggregate ( geometry , zone , value , increment , transform , mask , out ) Disaggregate uniformly value over the extent given by geometry (must be a polygon) onto target pixels in raster zone . Parameters: Name Type Description Default geometry ndarray Sequence of float32 coordinate pairs (x, y), defining a polygon exterior ring, first and last point must be the same required zone ndarray 'int8' raster which defines where the targets pixels are : values in zone should be such as target pixels = 2, fallback pixels = 1, nodata = 0 required value float The value to disaggregate over the extent of geometry required transform Affine RasterIO transform from geometry coordinate system to raster pixel coordinates. required mask ndarray temporary 'uint8' raster that can be reused between successive calls to disaggregate ; must be initialized to zeros. required out ndarray Output float32 raster, receiving disaggregated increments that sum up to value . The disaggregated values are added to pixel values in out required fct . algorithms . terrain . flat_mask_flowdir ( mask , flow , labels ) Assign drainage direction to flat areas, according to pseudo-height in mask . Input flow raster is modified in place. See also: resolve_flat() Parameters: Name Type Description Default mask ndarray Pseudo-height raster (float32 array) required flow ndarray D8 flow firection raster (int16 array) required labels ndarray Flat label raster (uint32 array) required Returns: Type Description ndarray Modified D8 flow direction raster (int16 array), nodata = -1 fct . algorithms . terrain . flowdir ( elevations , nodata , flow = None ) Flow direction from elevation data. Assign flow direction toward the lower neighbouring cell. Parameters: Name Type Description Default elevations ndarray Elevation raster (DEM), array-like, ndims=2, dtype=float32 required nodata float No data value for elevation required flow Optional[numpy.ndarray] Output array initialized to -1 None Returns: Type Description ndarray D8 flow direction array, nodata = -1 fct . algorithms . terrain . outlet ( flow , i0 , j0 ) Find the outlet pixel draining pixel (i0, j0) Parameters: Name Type Description Default flow ndarray D8 flow firection raster (int16 array) required i0 int pixel row index required j0 int pixel column index required Returns: Type Description Tuple[int, int] (row, col) coordinates of outlet pixel draining origin pixel (i0, j0) fct . algorithms . terrain . resolve_flat ( elevations , flow ) Create a pseudo-height raster for DEM flats, suitable to calculate a realistic drainage direction raster. Parameters: Name Type Description Default elevations ndarray Digital elevation model (DEM) raster, dtype 'float32', preprocessed for depression filling. Flats must have constant elevation. required flow ndarray D8 flow firection raster (int16 array) required Returns: Type Description Tuple[numpy.ndarray, numpy.ndarray] flat_mask: Pseudo-height raster (float32 array), nodata = 0 labels: Flat label raster (uint32 array), nodata = 0 fct . algorithms . terrain . signed_distance ( a , b , c ) Signed distance from points C to segments [AB]. Parameters: Name Type Description Default a ndarray vector of A points, array-like of pairs of float32 coordinates (x, y) required b ndarray vector of B points, array-like of pairs of float32 coordinates (x, y) required c ndarray vector of C points, array-like of pairs of float32 coordinates (x, y) required Returns: Type Description Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray] tuple of 3 float32 arrays : distance from C to segment [AB] signed distance from C to infinite line (AB) normalized distance of C's nearest point on [AB] from A, between 0.0 (C' == A) and 1.0 (C' == B) fct . algorithms . terrain . tile_outlets ( flow , mask = None ) Find all outlet pixels according to flow and calculate their local contributive area. An optional mask raster may be used when the tile boundaries do not align with the raster grid. Parameters: Name Type Description Default flow ndarray D8 flow firection raster (int16 array) required mask Optional[numpy.ndarray] validity mask (uint8 array), where value > 0 indicates a valid pixel None Returns: Type Description Tuple[List[Tuple[int, int, float]], List[Tuple[int, int]]] list of tile outlets (i, j, area) where area is the local area drained by pixel (i, j) list of target pixels (ix, jx) such as pixel (i, j) flows to pixel (ix, jx) fct . algorithms . terrain . watershed_labels ( elevations , nodata , noout , labels = None ) Fill sinks of digital elevation model (DEM), based on the algorithm of Wang & Liu (2006). Parameters: Name Type Description Default elevations ndarray Digital elevation model (DEM) raster, dtype 'float32' required nodata float no-data value in elevations required noout float no-out value in elevations Provide max(elevations) if not applicable required labels Optional[numpy.ndarray] Same shape and dtype as elevations, initialized to nodata None Returns: Type Description Tuple[numpy.ndarray, dict] 'uint32' aster map of watershed labels starting from 1, with nodata = 0 watershed graph: dict {(label1, label2): minz} where label1 < label2 and (label1, label2) denotes an undirected link between watershed 1 and watershed 2, and minz is the minimum connecting elevation between the two waterhseds.","title":"Terrain Analysis"},{"location":"ref/terrain/#terrain-analysis","text":"Some older code from FCT Terrain Analysis","title":"Terrain Analysis"},{"location":"ref/terrain/#fct.algorithms.terrain.disaggregate","text":"Disaggregate uniformly value over the extent given by geometry (must be a polygon) onto target pixels in raster zone . Parameters: Name Type Description Default geometry ndarray Sequence of float32 coordinate pairs (x, y), defining a polygon exterior ring, first and last point must be the same required zone ndarray 'int8' raster which defines where the targets pixels are : values in zone should be such as target pixels = 2, fallback pixels = 1, nodata = 0 required value float The value to disaggregate over the extent of geometry required transform Affine RasterIO transform from geometry coordinate system to raster pixel coordinates. required mask ndarray temporary 'uint8' raster that can be reused between successive calls to disaggregate ; must be initialized to zeros. required out ndarray Output float32 raster, receiving disaggregated increments that sum up to value . The disaggregated values are added to pixel values in out required","title":"disaggregate()"},{"location":"ref/terrain/#fct.algorithms.terrain.flat_mask_flowdir","text":"Assign drainage direction to flat areas, according to pseudo-height in mask . Input flow raster is modified in place. See also: resolve_flat() Parameters: Name Type Description Default mask ndarray Pseudo-height raster (float32 array) required flow ndarray D8 flow firection raster (int16 array) required labels ndarray Flat label raster (uint32 array) required Returns: Type Description ndarray Modified D8 flow direction raster (int16 array), nodata = -1","title":"flat_mask_flowdir()"},{"location":"ref/terrain/#fct.algorithms.terrain.flowdir","text":"Flow direction from elevation data. Assign flow direction toward the lower neighbouring cell. Parameters: Name Type Description Default elevations ndarray Elevation raster (DEM), array-like, ndims=2, dtype=float32 required nodata float No data value for elevation required flow Optional[numpy.ndarray] Output array initialized to -1 None Returns: Type Description ndarray D8 flow direction array, nodata = -1","title":"flowdir()"},{"location":"ref/terrain/#fct.algorithms.terrain.outlet","text":"Find the outlet pixel draining pixel (i0, j0) Parameters: Name Type Description Default flow ndarray D8 flow firection raster (int16 array) required i0 int pixel row index required j0 int pixel column index required Returns: Type Description Tuple[int, int] (row, col) coordinates of outlet pixel draining origin pixel (i0, j0)","title":"outlet()"},{"location":"ref/terrain/#fct.algorithms.terrain.resolve_flat","text":"Create a pseudo-height raster for DEM flats, suitable to calculate a realistic drainage direction raster. Parameters: Name Type Description Default elevations ndarray Digital elevation model (DEM) raster, dtype 'float32', preprocessed for depression filling. Flats must have constant elevation. required flow ndarray D8 flow firection raster (int16 array) required Returns: Type Description Tuple[numpy.ndarray, numpy.ndarray] flat_mask: Pseudo-height raster (float32 array), nodata = 0 labels: Flat label raster (uint32 array), nodata = 0","title":"resolve_flat()"},{"location":"ref/terrain/#fct.algorithms.terrain.signed_distance","text":"Signed distance from points C to segments [AB]. Parameters: Name Type Description Default a ndarray vector of A points, array-like of pairs of float32 coordinates (x, y) required b ndarray vector of B points, array-like of pairs of float32 coordinates (x, y) required c ndarray vector of C points, array-like of pairs of float32 coordinates (x, y) required Returns: Type Description Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray] tuple of 3 float32 arrays : distance from C to segment [AB] signed distance from C to infinite line (AB) normalized distance of C's nearest point on [AB] from A, between 0.0 (C' == A) and 1.0 (C' == B)","title":"signed_distance()"},{"location":"ref/terrain/#fct.algorithms.terrain.tile_outlets","text":"Find all outlet pixels according to flow and calculate their local contributive area. An optional mask raster may be used when the tile boundaries do not align with the raster grid. Parameters: Name Type Description Default flow ndarray D8 flow firection raster (int16 array) required mask Optional[numpy.ndarray] validity mask (uint8 array), where value > 0 indicates a valid pixel None Returns: Type Description Tuple[List[Tuple[int, int, float]], List[Tuple[int, int]]] list of tile outlets (i, j, area) where area is the local area drained by pixel (i, j) list of target pixels (ix, jx) such as pixel (i, j) flows to pixel (ix, jx)","title":"tile_outlets()"},{"location":"ref/terrain/#fct.algorithms.terrain.watershed_labels","text":"Fill sinks of digital elevation model (DEM), based on the algorithm of Wang & Liu (2006). Parameters: Name Type Description Default elevations ndarray Digital elevation model (DEM) raster, dtype 'float32' required nodata float no-data value in elevations required noout float no-out value in elevations Provide max(elevations) if not applicable required labels Optional[numpy.ndarray] Same shape and dtype as elevations, initialized to nodata None Returns: Type Description Tuple[numpy.ndarray, dict] 'uint32' aster map of watershed labels starting from 1, with nodata = 0 watershed graph: dict {(label1, label2): minz} where label1 < label2 and (label1, label2) denotes an undirected link between watershed 1 and watershed 2, and minz is the minimum connecting elevation between the two waterhseds.","title":"watershed_labels()"},{"location":"ref/transform/","text":"Transform GeoTransform module : replacement for RasterIO .index() and .xy() methods vectorized transformation of NumPy array of coordinates fct . algorithms . transform . index ( x , y , transform ) Transform real world coordinates (x, y) into raster pixel coordinates (py, px) Parameters: Name Type Description Default x float x real world coordinates required y float y real world coordinates required transform Tuple GDAL GeoTransform tuple or RasterIO Affine Transform object required Returns: Type Description Tuple[int, int] Raster pixel coordinates (row, col) fct . algorithms . transform . pixeltoworld ( pixels , transform ) Transform raster pixel coordinates (py, px) into real world coordinates (x, y) Parameters: Name Type Description Default pixels ndarray array of (row, col) raster coordinates with dtype 'int32' required transform Tuple GDAL GeoTransform tuple or RasterIO Affine Transform object required Returns: Type Description ndarray Real world coordinates array with dtype 'float32' fct . algorithms . transform . worldtopixel ( coordinates , transform ) Transform real world coordinates (x, y) into raster pixel coordinates (py, px) Parameters: Name Type Description Default coordinates ndarray array of (x, y) coordinates with dtype 'float32' required transform Tuple GDAL GeoTransform tuple or RasterIO Affine Transform object required Returns: Type Description ndarray Raster pixel coordinates array with dtype 'int32' fct . algorithms . transform . xy ( row , col , transform ) Transform raster pixel coordinates (py, px) into real world coordinates (x, y) Parameters: Name Type Description Default row int pixel row index required col int pixel column index required transform Tuple GDAL GeoTransform tuple or RasterIO Affine Transform object required Returns: Type Description Tuple[float, float] Real world coordinates (x, y)","title":"Transform"},{"location":"ref/transform/#transform","text":"GeoTransform module : replacement for RasterIO .index() and .xy() methods vectorized transformation of NumPy array of coordinates","title":"Transform"},{"location":"ref/transform/#fct.algorithms.transform.index","text":"Transform real world coordinates (x, y) into raster pixel coordinates (py, px) Parameters: Name Type Description Default x float x real world coordinates required y float y real world coordinates required transform Tuple GDAL GeoTransform tuple or RasterIO Affine Transform object required Returns: Type Description Tuple[int, int] Raster pixel coordinates (row, col)","title":"index()"},{"location":"ref/transform/#fct.algorithms.transform.pixeltoworld","text":"Transform raster pixel coordinates (py, px) into real world coordinates (x, y) Parameters: Name Type Description Default pixels ndarray array of (row, col) raster coordinates with dtype 'int32' required transform Tuple GDAL GeoTransform tuple or RasterIO Affine Transform object required Returns: Type Description ndarray Real world coordinates array with dtype 'float32'","title":"pixeltoworld()"},{"location":"ref/transform/#fct.algorithms.transform.worldtopixel","text":"Transform real world coordinates (x, y) into raster pixel coordinates (py, px) Parameters: Name Type Description Default coordinates ndarray array of (x, y) coordinates with dtype 'float32' required transform Tuple GDAL GeoTransform tuple or RasterIO Affine Transform object required Returns: Type Description ndarray Raster pixel coordinates array with dtype 'int32'","title":"worldtopixel()"},{"location":"ref/transform/#fct.algorithms.transform.xy","text":"Transform raster pixel coordinates (py, px) into real world coordinates (x, y) Parameters: Name Type Description Default row int pixel row index required col int pixel column index required transform Tuple GDAL GeoTransform tuple or RasterIO Affine Transform object required Returns: Type Description Tuple[float, float] Real world coordinates (x, y)","title":"xy()"},{"location":"workflows/continuity/","text":"Corridor Continuity Lorem ...","title":"Corridor Continuity"},{"location":"workflows/continuity/#corridor-continuity","text":"Lorem ...","title":"Corridor Continuity"},{"location":"workflows/drainage/","text":"Drainage Overview graph LR In1(DEM) --> A subgraph Rasters A[precondition<br>resolve flats] --> B B[caclulate<br>flow] --> C end subgraph Network C[accumulate] --> D[vectorize] end B --> Out1(flow<br>direction) C --> Out2(drainage<br>area) D --> Out3(stream<br>network) Example Workflow DrainageRastersWorkflow ( processes = 6 ) Resolve flow direction and calculate drainage rasters Parameters: Name Type Description Default processes int process tiles using n parallel processes 6 Source code in workflows/DrainageRasters.py def DrainageRastersWorkflow ( processes = 6 ): \"\"\" Resolve flow direction and calculate drainage rasters Arguments: processes (int): process tiles using n parallel processes \"\"\" with WorkflowContext () as ctx : # ctx.set_outputdir() extract_dem_tiles ( ctx , exterior = 'off' , smoothing_window = 0 , processes = processes ) smooth_elevations ( ctx , window = 5 , processes = processes ) drape_stream_network ( ctx , elevations = 'smoothed' ) depression_fill ( ctx , elevations = 'smoothed' , burn_offset = 2.0 , processes = processes ) resolve_flats ( ctx , espilon = 0.0005 , processes = processes ) flat_depth ( ctx , processes = processes ) flow_direction ( ctx , processes = processes ) accumulate ( ctx , processes = processes ) # find_noflow_pixels(ctx) # doit_again_with_other_tileset() # fix_noflow_pixels() return ctx Example Workflow DrainageNetworkWorkflow ( min_drainage = 5.0 , processes = 6 ) Vectorize drainage network from drainage raster (one step workflow) Parameters: Name Type Description Default min_drainage float minimum drainage area for stream extraction expressed in square kilometers 5.0 processes int process tiles using n parallel processes 6 Source code in workflows/DrainageNetwork.py def DrainageNetworkWorkflow ( min_drainage = 5.0 , processes = 6 ): \"\"\" Vectorize drainage network from drainage raster (one step workflow) Arguments: min_drainage (float): minimum drainage area for stream extraction expressed in square kilometers processes (int): process tiles using n parallel processes \"\"\" with WorkflowContext () as ctx : # ctx.set_outputdir() vectorize_drainage_network ( ctx , min_drainage = min_drainage , processes = processes ) return ctx Operations Drainage rasters Example Workflow accumulate ( processes ) Accumulate flow and calculate drainage area Source code in workflows/DrainageRasters.py @operation def accumulate ( processes ): \"\"\" Accumulate flow and calculate drainage area \"\"\" from fct.drainage.Accumulate import ( Parameters , TileOutlets , AggregateOutlets , InletAreas , FlowAccumulationTile ) tileset = config . tileset () params = Parameters () FindOutlets = parallel ( TileOutlets ) FindOutlets ( tileset , params , processes = processes ) AggregateOutlets ( params ) InletAreas ( params ) FlowAccumulation = parallel ( FlowAccumulationTile ) FlowAccumulation ( tileset , params , processes = processes , overwrite = True ) buildvrt ( 'default' , params . acc ) depression_fill ( elevations , burn_offset , processes ) Flat-fill DEM depressions Source code in workflows/DrainageRasters.py @operation def depression_fill ( elevations , burn_offset , processes ): \"\"\" Flat-fill DEM depressions \"\"\" from fct.drainage.DepressionFill import ( Parameters , LabelWatersheds as LabelTile , ResolveWatershedSpillover , DispatchWatershedMinimumZ as DispatchTile ) LabelWatersheds = parallel ( LabelTile ) DispatchMinimumZ = parallel ( DispatchTile ) tileset = config . tileset () params = Parameters () params . elevations = elevations params . offset = burn_offset LabelWatersheds ( tileset , params , processes = processes , overwrite = True , verbose = False ) ResolveWatershedSpillover ( params , overwrite = True ) DispatchMinimumZ ( tileset , params , processes = processes , overwrite = True ) drape_stream_network ( elevations ) Drape stream network on DEM and create network tiles Source code in workflows/DrainageRasters.py @operation def drape_stream_network ( elevations ): \"\"\" Drape stream network on DEM and create network tiles \"\"\" from fct.drainage.Drape import ( Parameters , DrapeNetworkAndAdjustElevations , SplitStreamNetworkIntoTiles ) params = Parameters () params . elevations = elevations DrapeNetworkAndAdjustElevations ( params ) SplitStreamNetworkIntoTiles ( params ) extract_dem_tiles ( exterior , smoothing_window , processes ) Extract data and create tiles from source DEM Source code in workflows/DrainageRasters.py @operation def extract_dem_tiles ( exterior , smoothing_window , processes ): \"\"\" Extract data and create tiles from source DEM \"\"\" from fct.drainage.PrepareDEM import ( ExtractParameters , ExtractAndPatchTile ) ExtractAndPatchDEM = parallel ( ExtractAndPatchTile ) tileset = config . tileset () params = ExtractParameters () params . exterior = exterior params . smoothing_window = smoothing_window ExtractAndPatchDEM ( tileset , params , processes = processes , overwrite = True , verbose = False ) buildvrt ( 'default' , params . elevations ) flat_depth ( processes ) Map depression depth Source code in workflows/DrainageRasters.py @operation def flat_depth ( processes ): \"\"\" Map depression depth \"\"\" from fct.drainage.FlatMap import ( Parameters , DepressionDepthMap as DepressionDepthTile ) MapDepressionDepth = parallel ( DepressionDepthTile ) tileset = config . tileset () params = Parameters () MapDepressionDepth ( tileset , params , processes = processes ) buildvrt ( 'default' , params . output ) flow_direction ( processes ) Calculate D8 flow direction Source code in workflows/DrainageRasters.py @operation def flow_direction ( processes ): \"\"\" Calculate D8 flow direction \"\"\" from fct.drainage.FlowDirection import ( Parameters , FlowDirectionTile ) FlowDirection = parallel ( FlowDirectionTile ) tileset = config . tileset () params = Parameters () FlowDirection ( tileset , params , processes = processes ) buildvrt ( 'default' , params . flow ) resolve_flats ( espilon , processes ) Resolve DEM flats Source code in workflows/DrainageRasters.py @operation def resolve_flats ( espilon , processes ): \"\"\" Resolve DEM flats \"\"\" from fct.drainage.BorderFlats import ( Parameters , LabelBorderFlats , ResolveFlatSpillover , DispatchFlatMinimumZ ) LabelFlats = parallel ( LabelBorderFlats ) Dispatch = parallel ( DispatchFlatMinimumZ ) tileset = config . tileset () params = Parameters () LabelFlats ( tileset , params , processes = processes ) ResolveFlatSpillover ( params , espilon ) Dispatch ( tileset , params , processes = processes ) buildvrt ( 'default' , params . output ) smooth_elevations ( window , processes ) Apply a smoothing filter on elevation data Source code in workflows/DrainageRasters.py @operation def smooth_elevations ( window , processes ): \"\"\" Apply a smoothing filter on elevation data \"\"\" from fct.drainage.PrepareDEM import ( SmoothingParameters , MeanFilter ) SmoothDEM = parallel ( MeanFilter ) tileset = config . tileset () params = SmoothingParameters () params . window = window SmoothDEM ( tileset , params , processes = processes , overwrite = True ) buildvrt ( 'default' , params . output ) Drainage network Example Workflow vectorize_drainage_network ( min_drainage , processes ) Vectorize drainage network from drainage raster (base operation) Source code in workflows/DrainageNetwork.py @operation def vectorize_drainage_network ( min_drainage , processes ): \"\"\" Vectorize drainage network from drainage raster (base operation) \"\"\" from fct.drainage.StreamNetwork import ( Parameters , StreamToFeatureTile , AggregateStreams ) StreamToFeature = parallel ( StreamToFeatureTile ) tileset = config . tileset () params = Parameters () params . min_drainage = min_drainage StreamToFeature ( tileset , params , processes = processes ) AggregateStreams ( params )","title":"Drainage"},{"location":"workflows/drainage/#drainage","text":"","title":"Drainage"},{"location":"workflows/drainage/#overview","text":"graph LR In1(DEM) --> A subgraph Rasters A[precondition<br>resolve flats] --> B B[caclulate<br>flow] --> C end subgraph Network C[accumulate] --> D[vectorize] end B --> Out1(flow<br>direction) C --> Out2(drainage<br>area) D --> Out3(stream<br>network) Example Workflow","title":"Overview"},{"location":"workflows/drainage/#workflows.DrainageRasters.DrainageRastersWorkflow","text":"Resolve flow direction and calculate drainage rasters Parameters: Name Type Description Default processes int process tiles using n parallel processes 6 Source code in workflows/DrainageRasters.py def DrainageRastersWorkflow ( processes = 6 ): \"\"\" Resolve flow direction and calculate drainage rasters Arguments: processes (int): process tiles using n parallel processes \"\"\" with WorkflowContext () as ctx : # ctx.set_outputdir() extract_dem_tiles ( ctx , exterior = 'off' , smoothing_window = 0 , processes = processes ) smooth_elevations ( ctx , window = 5 , processes = processes ) drape_stream_network ( ctx , elevations = 'smoothed' ) depression_fill ( ctx , elevations = 'smoothed' , burn_offset = 2.0 , processes = processes ) resolve_flats ( ctx , espilon = 0.0005 , processes = processes ) flat_depth ( ctx , processes = processes ) flow_direction ( ctx , processes = processes ) accumulate ( ctx , processes = processes ) # find_noflow_pixels(ctx) # doit_again_with_other_tileset() # fix_noflow_pixels() return ctx Example Workflow","title":"DrainageRastersWorkflow()"},{"location":"workflows/drainage/#workflows.DrainageNetwork.DrainageNetworkWorkflow","text":"Vectorize drainage network from drainage raster (one step workflow) Parameters: Name Type Description Default min_drainage float minimum drainage area for stream extraction expressed in square kilometers 5.0 processes int process tiles using n parallel processes 6 Source code in workflows/DrainageNetwork.py def DrainageNetworkWorkflow ( min_drainage = 5.0 , processes = 6 ): \"\"\" Vectorize drainage network from drainage raster (one step workflow) Arguments: min_drainage (float): minimum drainage area for stream extraction expressed in square kilometers processes (int): process tiles using n parallel processes \"\"\" with WorkflowContext () as ctx : # ctx.set_outputdir() vectorize_drainage_network ( ctx , min_drainage = min_drainage , processes = processes ) return ctx","title":"DrainageNetworkWorkflow()"},{"location":"workflows/drainage/#operations","text":"","title":"Operations"},{"location":"workflows/drainage/#drainage-rasters","text":"Example Workflow","title":"Drainage rasters"},{"location":"workflows/drainage/#workflows.DrainageRasters.accumulate","text":"Accumulate flow and calculate drainage area Source code in workflows/DrainageRasters.py @operation def accumulate ( processes ): \"\"\" Accumulate flow and calculate drainage area \"\"\" from fct.drainage.Accumulate import ( Parameters , TileOutlets , AggregateOutlets , InletAreas , FlowAccumulationTile ) tileset = config . tileset () params = Parameters () FindOutlets = parallel ( TileOutlets ) FindOutlets ( tileset , params , processes = processes ) AggregateOutlets ( params ) InletAreas ( params ) FlowAccumulation = parallel ( FlowAccumulationTile ) FlowAccumulation ( tileset , params , processes = processes , overwrite = True ) buildvrt ( 'default' , params . acc )","title":"accumulate()"},{"location":"workflows/drainage/#workflows.DrainageRasters.depression_fill","text":"Flat-fill DEM depressions Source code in workflows/DrainageRasters.py @operation def depression_fill ( elevations , burn_offset , processes ): \"\"\" Flat-fill DEM depressions \"\"\" from fct.drainage.DepressionFill import ( Parameters , LabelWatersheds as LabelTile , ResolveWatershedSpillover , DispatchWatershedMinimumZ as DispatchTile ) LabelWatersheds = parallel ( LabelTile ) DispatchMinimumZ = parallel ( DispatchTile ) tileset = config . tileset () params = Parameters () params . elevations = elevations params . offset = burn_offset LabelWatersheds ( tileset , params , processes = processes , overwrite = True , verbose = False ) ResolveWatershedSpillover ( params , overwrite = True ) DispatchMinimumZ ( tileset , params , processes = processes , overwrite = True )","title":"depression_fill()"},{"location":"workflows/drainage/#workflows.DrainageRasters.drape_stream_network","text":"Drape stream network on DEM and create network tiles Source code in workflows/DrainageRasters.py @operation def drape_stream_network ( elevations ): \"\"\" Drape stream network on DEM and create network tiles \"\"\" from fct.drainage.Drape import ( Parameters , DrapeNetworkAndAdjustElevations , SplitStreamNetworkIntoTiles ) params = Parameters () params . elevations = elevations DrapeNetworkAndAdjustElevations ( params ) SplitStreamNetworkIntoTiles ( params )","title":"drape_stream_network()"},{"location":"workflows/drainage/#workflows.DrainageRasters.extract_dem_tiles","text":"Extract data and create tiles from source DEM Source code in workflows/DrainageRasters.py @operation def extract_dem_tiles ( exterior , smoothing_window , processes ): \"\"\" Extract data and create tiles from source DEM \"\"\" from fct.drainage.PrepareDEM import ( ExtractParameters , ExtractAndPatchTile ) ExtractAndPatchDEM = parallel ( ExtractAndPatchTile ) tileset = config . tileset () params = ExtractParameters () params . exterior = exterior params . smoothing_window = smoothing_window ExtractAndPatchDEM ( tileset , params , processes = processes , overwrite = True , verbose = False ) buildvrt ( 'default' , params . elevations )","title":"extract_dem_tiles()"},{"location":"workflows/drainage/#workflows.DrainageRasters.flat_depth","text":"Map depression depth Source code in workflows/DrainageRasters.py @operation def flat_depth ( processes ): \"\"\" Map depression depth \"\"\" from fct.drainage.FlatMap import ( Parameters , DepressionDepthMap as DepressionDepthTile ) MapDepressionDepth = parallel ( DepressionDepthTile ) tileset = config . tileset () params = Parameters () MapDepressionDepth ( tileset , params , processes = processes ) buildvrt ( 'default' , params . output )","title":"flat_depth()"},{"location":"workflows/drainage/#workflows.DrainageRasters.flow_direction","text":"Calculate D8 flow direction Source code in workflows/DrainageRasters.py @operation def flow_direction ( processes ): \"\"\" Calculate D8 flow direction \"\"\" from fct.drainage.FlowDirection import ( Parameters , FlowDirectionTile ) FlowDirection = parallel ( FlowDirectionTile ) tileset = config . tileset () params = Parameters () FlowDirection ( tileset , params , processes = processes ) buildvrt ( 'default' , params . flow )","title":"flow_direction()"},{"location":"workflows/drainage/#workflows.DrainageRasters.resolve_flats","text":"Resolve DEM flats Source code in workflows/DrainageRasters.py @operation def resolve_flats ( espilon , processes ): \"\"\" Resolve DEM flats \"\"\" from fct.drainage.BorderFlats import ( Parameters , LabelBorderFlats , ResolveFlatSpillover , DispatchFlatMinimumZ ) LabelFlats = parallel ( LabelBorderFlats ) Dispatch = parallel ( DispatchFlatMinimumZ ) tileset = config . tileset () params = Parameters () LabelFlats ( tileset , params , processes = processes ) ResolveFlatSpillover ( params , espilon ) Dispatch ( tileset , params , processes = processes ) buildvrt ( 'default' , params . output )","title":"resolve_flats()"},{"location":"workflows/drainage/#workflows.DrainageRasters.smooth_elevations","text":"Apply a smoothing filter on elevation data Source code in workflows/DrainageRasters.py @operation def smooth_elevations ( window , processes ): \"\"\" Apply a smoothing filter on elevation data \"\"\" from fct.drainage.PrepareDEM import ( SmoothingParameters , MeanFilter ) SmoothDEM = parallel ( MeanFilter ) tileset = config . tileset () params = SmoothingParameters () params . window = window SmoothDEM ( tileset , params , processes = processes , overwrite = True ) buildvrt ( 'default' , params . output )","title":"smooth_elevations()"},{"location":"workflows/drainage/#drainage-network","text":"Example Workflow","title":"Drainage network"},{"location":"workflows/drainage/#workflows.DrainageNetwork.vectorize_drainage_network","text":"Vectorize drainage network from drainage raster (base operation) Source code in workflows/DrainageNetwork.py @operation def vectorize_drainage_network ( min_drainage , processes ): \"\"\" Vectorize drainage network from drainage raster (base operation) \"\"\" from fct.drainage.StreamNetwork import ( Parameters , StreamToFeatureTile , AggregateStreams ) StreamToFeature = parallel ( StreamToFeatureTile ) tileset = config . tileset () params = Parameters () params . min_drainage = min_drainage StreamToFeature ( tileset , params , processes = processes ) AggregateStreams ( params )","title":"vectorize_drainage_network()"},{"location":"workflows/heights/","text":"Heights Relative Heights Valley Bottom Delineation","title":"Heights"},{"location":"workflows/heights/#heights","text":"","title":"Heights"},{"location":"workflows/heights/#relative-heights","text":"","title":"Relative Heights"},{"location":"workflows/heights/#valley-bottom-delineation","text":"","title":"Valley Bottom Delineation"},{"location":"workflows/metrics/","text":"Metric Profiles Metrics, Measurements, Profiles Swath Profiles Lorem ... Longitudinal Profiles Lorem ...","title":"Metric Profiles"},{"location":"workflows/metrics/#metric-profiles","text":"Metrics, Measurements, Profiles","title":"Metric Profiles"},{"location":"workflows/metrics/#swath-profiles","text":"Lorem ...","title":"Swath Profiles"},{"location":"workflows/metrics/#longitudinal-profiles","text":"Lorem ...","title":"Longitudinal Profiles"},{"location":"workflows/swaths/","text":"Swaths Creation","title":"Swaths Creation"},{"location":"workflows/swaths/#swaths-creation","text":"","title":"Swaths Creation"}]}